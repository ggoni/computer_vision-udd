"""Repository for Detection entities using async SQLAlchemy."""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Tuple
from uuid import UUID

from sqlalchemy import delete, func, select
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.detection import Detection


class DetectionRepository:
    """Data access operations for Detection entities."""

    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def create_many(self, detections: List[Dict[str, Any]]) -> List[Detection]:
        """Bulk insert multiple detections and return created instances."""
        if not detections:
            return []

        objects = [Detection(**d) for d in detections]
        self._session.add_all(objects)
        await self._session.flush()
        # Refresh to ensure autogenerated fields are populated (ids/timestamps)
        for obj in objects:
            await self._session.refresh(obj)
        return objects

    async def get_by_image_id(self, image_id: UUID) -> List[Detection]:
        """Return detections for an image ordered by confidence desc."""
        stmt = (
            select(Detection)
            .where(Detection.image_id == image_id)
            .order_by(Detection.confidence_score.desc())
        )
        result = await self._session.execute(stmt)
        return list(result.scalars().all())

    async def get_paginated(
        self,
        *,
        page: int,
        page_size: int,
        label: Optional[str] = None,
        min_confidence: Optional[float] = None,
    ) -> Tuple[List[Detection], int]:
        """Return (items, total_count) with optional filters.

        Items ordered by confidence desc, then created_at desc.
        """

        if page <= 0 or page_size <= 0:
            return ([], 0)

        conditions = []
        if label is not None:
            conditions.append(Detection.label == label)
        if min_confidence is not None:
            conditions.append(Detection.confidence_score >= min_confidence)

        base = select(Detection)
        if conditions:
            for cond in conditions:
                base = base.where(cond)

        # total count
        count_stmt = base.with_only_columns(func.count()).order_by(None)
        total = (await self._session.execute(count_stmt)).scalar_one()

        # page items
        stmt = (
            base.order_by(Detection.confidence_score.desc(), Detection.created_at.desc())
            .offset((page - 1) * page_size)
            .limit(page_size)
        )
        result = await self._session.execute(stmt)
        items = list(result.scalars().all())
        return (items, total)

    async def delete_by_image_id(self, image_id: UUID) -> int:
        """Delete detections for an image; return number of rows deleted."""
        stmt = delete(Detection).where(Detection.image_id == image_id)
        res = await self._session.execute(stmt)
        await self._session.flush()
        # res.rowcount can be None depending on dialect; fallback to 0
        return int(res.rowcount or 0)
