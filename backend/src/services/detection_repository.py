"""Repository for Detection entities using async SQLAlchemy."""

from __future__ import annotations

from typing import Any
from uuid import UUID

from sqlalchemy import delete, func, select
from sqlalchemy.ext.asyncio import AsyncSession

from src.models.detection import Detection


class DetectionRepository:
    """Data access operations for Detection entities."""

    def __init__(self, session: AsyncSession) -> None:
        self._session = session

    async def create_many(self, detections: list[dict[str, Any]]) -> list[Detection]:
        """Bulk insert multiple detections and return created instances."""
        if not detections:
            return []

        objects = [Detection(**d) for d in detections]
        self._session.add_all(objects)
        await self._session.flush()
        # Refresh to ensure autogenerated fields are populated (ids/timestamps)
        for obj in objects:
            await self._session.refresh(obj)
        return objects

    async def get_by_image_id(self, image_id: UUID) -> list[Detection]:
        """Return detections for an image ordered by confidence desc."""
        stmt = (
            select(Detection)
            .where(Detection.image_id == image_id)
            .order_by(Detection.confidence_score.desc())
        )
        result = await self._session.execute(stmt)
        return list(result.scalars().all())

    async def get_paginated(
        self,
        *,
        page: int,
        page_size: int,
        label: str | None = None,
        min_confidence: float | None = None,
    ) -> tuple[list[Detection], int]:
        """Return (items, total_count) with optional filters.

        Items ordered by confidence desc, then created_at desc.
        """

        if page <= 0 or page_size <= 0:
            return ([], 0)

        # Build base query
        base = select(Detection)
        if label is not None:
            base = base.where(Detection.label == label)
        if min_confidence is not None:
            base = base.where(Detection.confidence_score >= min_confidence)

        # Build count query with same filters
        count_stmt = select(func.count()).select_from(Detection)
        if label is not None:
            count_stmt = count_stmt.where(Detection.label == label)
        if min_confidence is not None:
            count_stmt = count_stmt.where(Detection.confidence_score >= min_confidence)

        total = (await self._session.execute(count_stmt)).scalar_one()

        # page items
        stmt = (
            base.order_by(
                Detection.confidence_score.desc(), Detection.created_at.desc()
            )
            .offset((page - 1) * page_size)
            .limit(page_size)
        )
        result = await self._session.execute(stmt)
        items = list(result.scalars().all())
        return (items, total)

    async def delete_by_image_id(self, image_id: UUID) -> int:
        """Delete detections for an image; return number of rows deleted."""
        stmt = delete(Detection).where(Detection.image_id == image_id)
        res = await self._session.execute(stmt)
        await self._session.flush()
        # res.rowcount can be None depending on dialect; fallback to 0
        return int(res.rowcount or 0)
